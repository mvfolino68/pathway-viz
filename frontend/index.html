<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamViz</title>
    <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.30/dist/uPlot.min.css">
    <script src="https://unpkg.com/uplot@1.6.30/dist/uPlot.iife.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg: #0f0f1a;
            --surface: rgba(255,255,255,0.03);
            --border: rgba(255,255,255,0.08);
            --text: #e0e0e0;
            --text-muted: #888;
            --primary: #00d4ff;
            --success: #00ff88;
            --warning: #ffd93d;
            --error: #ff6b6b;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
        }

        /* Full dashboard mode */
        body.dashboard-mode {
            padding: 24px;
        }

        /* Embed mode - minimal chrome */
        body.embed-mode {
            padding: 8px;
        }
        body.embed-mode header,
        body.embed-mode .stats-bar {
            display: none;
        }
        body.embed-mode #widgets {
            display: block;
        }
        body.embed-mode .widget {
            height: 100%;
            min-height: auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(90deg, var(--primary), #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #status.connected { background: rgba(0,255,136,0.1); color: var(--success); }
        #status.disconnected { background: rgba(255,68,68,0.1); color: var(--error); }
        #status::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        #widgets {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .widget {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            min-height: 100px;
        }

        .widget-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .widget-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Metric Widget (time series) */
        .metric .current-value {
            font-size: 2rem;
            font-weight: 600;
            line-height: 1;
        }
        .metric .unit {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-left: 4px;
        }
        .metric .chart-container {
            margin-top: 12px;
        }

        /* Stat Widget (big number) */
        .stat {
            text-align: center;
            padding: 30px 20px;
        }
        .stat .value {
            font-size: 3rem;
            font-weight: 700;
            line-height: 1;
        }
        .stat .delta {
            font-size: 1rem;
            margin-top: 8px;
        }
        .stat .delta.positive { color: var(--success); }
        .stat .delta.negative { color: var(--error); }

        /* Gauge Widget */
        .gauge {
            text-align: center;
        }
        .gauge svg {
            width: 150px;
            height: 100px;
            margin: 0 auto;
        }
        .gauge .gauge-value {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 8px;
        }
        .gauge-track { fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 12; }
        .gauge-fill { fill: none; stroke-width: 12; stroke-linecap: round; transition: stroke-dashoffset 0.3s; }

        /* Table Widget */
        .table-widget {
            overflow-x: auto;
        }
        .table-widget table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        .table-widget th {
            text-align: left;
            padding: 10px 12px;
            border-bottom: 2px solid var(--border);
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
        }
        .table-widget td {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            transition: background 0.3s;
        }
        .table-widget tr:last-child td { border-bottom: none; }

        /* Pathway table - highlight on update */
        .pathway-table tr.row-highlight td {
            background: rgba(0, 212, 255, 0.12);
        }
        .pathway-table tr.row-delete td {
            background: rgba(255, 107, 107, 0.12);
            opacity: 0.5;
        }

        /* Manual table - new row animation */
        .table-widget:not(.pathway-table) tr {
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .table-widget .badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .badge-ERROR { background: rgba(255,107,107,0.2); color: var(--error); }
        .badge-WARN { background: rgba(255,217,61,0.2); color: var(--warning); }
        .badge-INFO { background: rgba(0,212,255,0.2); color: var(--primary); }
        .badge-DEBUG { background: rgba(255,255,255,0.1); color: var(--text-muted); }

        /* Numeric formatting */
        .table-widget td.numeric {
            font-family: 'SF Mono', 'Consolas', monospace;
            text-align: right;
        }

        /* Text Widget */
        .text-widget { padding: 16px; }
        .text-widget.style-caption { font-size: 0.85rem; color: var(--text-muted); }
        .text-widget.style-code { font-family: monospace; background: rgba(0,0,0,0.3); }

        /* Footer Stats */
        .stats-bar {
            display: flex;
            gap: 24px;
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            justify-content: center;
        }
        .stat-item { text-align: center; }
        .stat-item .value { font-size: 1.25rem; font-weight: 600; color: var(--primary); }
        .stat-item .label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }

        #waiting {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            color: var(--text-muted);
        }
        #waiting .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .u-legend { display: none; }

        /* Responsive tweaks */
        @media (max-width: 600px) {
            body.dashboard-mode { padding: 12px; }
            #widgets { gap: 12px; }
            .widget { padding: 16px; }
            .stat .value { font-size: 2rem; }
        }
    </style>
</head>
<body class="dashboard-mode">
    <header>
        <h1 id="title">StreamViz</h1>
        <div id="status" class="disconnected">Connecting</div>
    </header>

    <div id="waiting">
        <div class="spinner"></div>
        <div>Waiting for data...</div>
    </div>

    <div id="widgets"></div>

    <div class="stats-bar">
        <div class="stat-item">
            <div class="value" id="msg-rate">0</div>
            <div class="label">msg/sec</div>
        </div>
        <div class="stat-item">
            <div class="value" id="total-msgs">0</div>
            <div class="label">Total</div>
        </div>
        <div class="stat-item">
            <div class="value" id="uptime">0s</div>
            <div class="label">Uptime</div>
        </div>
    </div>

    <script>
        // =================================================================
        // Configuration & State
        // =================================================================

        const params = new URLSearchParams(window.location.search);
        const embedWidget = params.get('widget');  // Single widget embed mode
        const embedMode = params.get('embed') === 'true' || embedWidget !== null;

        if (embedMode) {
            document.body.classList.remove('dashboard-mode');
            document.body.classList.add('embed-mode');
        }

        const widgets = {};  // widget_id -> state
        let msgCount = 0;
        let msgsLastSec = 0;
        let lastRateUpdate = Date.now();
        const startTime = Date.now();

        const titleEl = document.getElementById('title');
        const statusEl = document.getElementById('status');
        const widgetsEl = document.getElementById('widgets');
        const waitingEl = document.getElementById('waiting');

        // =================================================================
        // Widget Factory
        // =================================================================

        function createMetricWidget(id, config) {
            const div = document.createElement('div');
            div.className = 'widget metric';
            div.id = `widget-${id}`;
            div.innerHTML = `
                <div class="widget-header">
                    <div class="widget-title">${escapeHtml(config.title)}</div>
                    <div>
                        <span class="current-value" style="color: ${config.color}">--</span>
                        <span class="unit">${escapeHtml(config.unit || '')}</span>
                    </div>
                </div>
                <div class="chart-container"></div>
            `;
            widgetsEl.appendChild(div);

            const container = div.querySelector('.chart-container');
            const timeData = [];
            const valueData = [];

            const opts = {
                width: container.offsetWidth || 400,
                height: embedMode ? 200 : 120,
                series: [{}, { stroke: config.color, width: 2, fill: config.color + "15" }],
                scales: { x: { time: true }, y: { auto: true } },
                axes: [
                    { stroke: "#555", grid: { stroke: "rgba(255,255,255,0.03)" }, font: "10px sans-serif", size: 25 },
                    { stroke: "#555", grid: { stroke: "rgba(255,255,255,0.05)" }, font: "10px sans-serif", size: 45 }
                ],
                cursor: { show: true },
                legend: { show: false }
            };

            const uplot = new uPlot(opts, [timeData, valueData], container);

            widgets[id] = {
                type: 'metric',
                config,
                element: div,
                valueEl: div.querySelector('.current-value'),
                timeData,
                valueData,
                uplot,
                maxPoints: config.max_points || 200
            };
        }

        function createStatWidget(id, config) {
            const div = document.createElement('div');
            div.className = 'widget stat';
            div.id = `widget-${id}`;
            div.innerHTML = `
                <div class="widget-title">${escapeHtml(config.title)}</div>
                <div class="value" style="color: ${config.color}">--</div>
                <div class="delta"></div>
            `;
            widgetsEl.appendChild(div);

            widgets[id] = {
                type: 'stat',
                config,
                element: div,
                valueEl: div.querySelector('.value'),
                deltaEl: div.querySelector('.delta')
            };
        }

        function createGaugeWidget(id, config) {
            const div = document.createElement('div');
            div.className = 'widget gauge';
            div.id = `widget-${id}`;

            const radius = 60;
            const circumference = Math.PI * radius;

            div.innerHTML = `
                <div class="widget-title">${escapeHtml(config.title)}</div>
                <svg viewBox="0 0 150 90">
                    <path class="gauge-track" d="M 15 75 A 60 60 0 0 1 135 75"/>
                    <path class="gauge-fill" d="M 15 75 A 60 60 0 0 1 135 75"
                          stroke="${config.color}"
                          stroke-dasharray="${circumference}"
                          stroke-dashoffset="${circumference}"/>
                </svg>
                <div class="gauge-value" style="color: ${config.color}">--<span class="unit">${escapeHtml(config.unit || '')}</span></div>
            `;
            widgetsEl.appendChild(div);

            widgets[id] = {
                type: 'gauge',
                config,
                element: div,
                fillEl: div.querySelector('.gauge-fill'),
                valueEl: div.querySelector('.gauge-value'),
                circumference,
                min: config.min || 0,
                max: config.max || 100
            };
        }

        function createTableWidget(id, config) {
            const div = document.createElement('div');
            div.className = 'widget table-widget';
            div.id = `widget-${id}`;

            const columns = config.columns || [];
            const headerHtml = columns.map(c =>
                `<th>${escapeHtml(c.label || c.name)}</th>`
            ).join('');

            div.innerHTML = `
                <div class="widget-title">${escapeHtml(config.title)}</div>
                <table>
                    <thead><tr>${headerHtml}</tr></thead>
                    <tbody></tbody>
                </table>
            `;
            widgetsEl.appendChild(div);

            widgets[id] = {
                type: 'table',
                config,
                element: div,
                tbody: div.querySelector('tbody'),
                rows: [],
                maxRows: config.max_rows || 50
            };
        }

        function createPathwayTableWidget(id, config) {
            const div = document.createElement('div');
            div.className = 'widget table-widget pathway-table';
            div.id = `widget-${id}`;

            const columns = config.columns || [];
            const headerHtml = columns.map(c =>
                `<th>${escapeHtml(c.label || c.name)}</th>`
            ).join('');

            div.innerHTML = `
                <div class="widget-title">${escapeHtml(config.title)}</div>
                <table>
                    <thead><tr>${headerHtml}</tr></thead>
                    <tbody></tbody>
                </table>
            `;
            widgetsEl.appendChild(div);

            widgets[id] = {
                type: 'pathway_table',
                config,
                element: div,
                tbody: div.querySelector('tbody'),
                rowsByKey: new Map(),  // key -> {tr, order}
                insertOrder: 0,
                maxRows: config.max_rows || 100
            };
        }

        function createTextWidget(id, config) {
            const div = document.createElement('div');
            div.className = `widget text-widget style-${config.style || 'body'}`;
            div.id = `widget-${id}`;
            div.textContent = config.value || '';
            widgetsEl.appendChild(div);

            widgets[id] = {
                type: 'text',
                config,
                element: div
            };
        }

        // =================================================================
        // Data Update Handlers
        // =================================================================

        function handleConfig(data) {
            titleEl.textContent = data.title || 'StreamViz';
            document.title = data.title || 'StreamViz';

            // In embed mode, only create the requested widget
            const widgetsToCreate = embedWidget
                ? { [embedWidget]: data.widgets?.[embedWidget] }
                : (data.widgets || {});

            for (const [id, config] of Object.entries(widgetsToCreate)) {
                if (!config || widgets[id]) continue;

                const type = config.widget_type;
                if (type === 'metric') createMetricWidget(id, config);
                else if (type === 'stat') createStatWidget(id, config);
                else if (type === 'gauge') createGaugeWidget(id, config);
                else if (type === 'table') createTableWidget(id, config);
                else if (type === 'pathway_table') createPathwayTableWidget(id, config);
                else if (type === 'text') createTextWidget(id, config);
            }

            waitingEl.style.display = 'none';
        }

        function handleData(data) {
            // In embed mode, only process the requested widget
            if (embedWidget && data.widget !== embedWidget) return;

            const w = widgets[data.widget];
            if (!w) return;

            msgCount++;
            msgsLastSec++;

            if (w.type === 'metric') updateMetric(w, data);
            else if (w.type === 'stat') updateStat(w, data);
            else if (w.type === 'gauge') updateGauge(w, data);
            else if (w.type === 'table') updateTable(w, data);
            else if (w.type === 'pathway_table') updatePathwayTable(w, data);
            else if (w.type === 'text') w.element.textContent = data.value;
        }

        function updateMetric(w, data) {
            const ts = data.timestamp / 1000;

            if (w.timeData.length >= w.maxPoints) {
                w.timeData.shift();
                w.valueData.shift();
            }
            w.timeData.push(ts);
            w.valueData.push(data.value);
            w.uplot.setData([w.timeData, w.valueData]);
            w.valueEl.textContent = formatValue(data.value);
        }

        function updateStat(w, data) {
            const formatted = formatValue(data.value);
            const unit = w.config.unit || '';
            w.valueEl.textContent = unit ? `${unit}${formatted}` : formatted;

            if (data.delta !== null && data.delta !== undefined) {
                const sign = data.delta >= 0 ? '+' : '';
                w.deltaEl.textContent = `${sign}${formatValue(data.delta)}`;
                w.deltaEl.className = `delta ${data.delta >= 0 ? 'positive' : 'negative'}`;
            }
        }

        function updateGauge(w, data) {
            const pct = Math.max(0, Math.min(1, (data.value - w.min) / (w.max - w.min)));
            const offset = w.circumference * (1 - pct);
            w.fillEl.style.strokeDashoffset = offset;

            // Update color based on thresholds
            if (w.config.thresholds) {
                for (const [threshold, color] of w.config.thresholds) {
                    if (data.value <= threshold) {
                        w.fillEl.style.stroke = color;
                        break;
                    }
                }
            }

            w.valueEl.innerHTML = `${formatValue(data.value)}<span class="unit">${escapeHtml(w.config.unit || '')}</span>`;
        }

        function updateTable(w, data) {
            const row = data.row;
            const columns = w.config.columns || [];

            const tr = document.createElement('tr');
            for (const col of columns) {
                const td = document.createElement('td');
                const val = row[col.name];

                if (col.name === 'level' || ['ERROR', 'WARN', 'INFO', 'DEBUG'].includes(val)) {
                    td.innerHTML = `<span class="badge badge-${val}">${escapeHtml(val)}</span>`;
                } else if (typeof val === 'number') {
                    td.textContent = formatValue(val);
                    td.className = 'numeric';
                } else {
                    td.textContent = val ?? '';
                }
                tr.appendChild(td);
            }

            w.tbody.insertBefore(tr, w.tbody.firstChild);

            while (w.tbody.children.length > w.maxRows) {
                w.tbody.removeChild(w.tbody.lastChild);
            }
        }

        function updatePathwayTable(w, data) {
            const columns = w.config.columns || [];
            const key = data.key;

            if (data.op === 'delete') {
                const existing = w.rowsByKey.get(key);
                if (existing) {
                    existing.tr.classList.add('row-delete');
                    setTimeout(() => {
                        existing.tr.remove();
                        w.rowsByKey.delete(key);
                    }, 300);
                }
                return;
            }

            // Upsert
            const row = data.row;
            let entry = w.rowsByKey.get(key);
            const isNew = !entry;

            if (isNew) {
                const tr = document.createElement('tr');
                tr.dataset.key = key;
                entry = { tr, order: w.insertOrder++ };
                w.rowsByKey.set(key, entry);
                w.tbody.appendChild(entry.tr);
            } else {
                entry.tr.innerHTML = '';
            }

            for (const col of columns) {
                const td = document.createElement('td');
                const val = row[col.name];

                if (val === undefined || val === null) {
                    td.textContent = '';
                } else if (typeof val === 'number') {
                    td.textContent = formatValue(val);
                    td.className = 'numeric';
                } else {
                    td.textContent = String(val);
                }
                entry.tr.appendChild(td);
            }

            // Highlight briefly
            entry.tr.classList.add('row-highlight');
            setTimeout(() => entry.tr.classList.remove('row-highlight'), 500);

            // Enforce max rows
            if (w.rowsByKey.size > w.maxRows) {
                let oldest = null;
                let oldestOrder = Infinity;
                for (const [k, v] of w.rowsByKey) {
                    if (v.order < oldestOrder) {
                        oldest = k;
                        oldestOrder = v.order;
                    }
                }
                if (oldest) {
                    const entry = w.rowsByKey.get(oldest);
                    entry.tr.remove();
                    w.rowsByKey.delete(oldest);
                }
            }
        }

        function handleHistory(data) {
            for (const item of (data.widgets || [])) {
                const w = widgets[item.widget];
                if (!w || w.type !== 'metric') continue;

                w.timeData.length = 0;
                w.valueData.length = 0;

                for (const [ts, val] of item.data) {
                    w.timeData.push(ts / 1000);
                    w.valueData.push(val);
                }

                w.uplot.setData([w.timeData, w.valueData]);

                if (item.data.length > 0) {
                    w.valueEl.textContent = formatValue(item.data[item.data.length - 1][1]);
                }
            }
        }

        // =================================================================
        // Utilities
        // =================================================================

        function formatValue(v) {
            if (v === null || v === undefined) return '--';
            if (typeof v !== 'number') return String(v);

            const abs = Math.abs(v);
            if (abs >= 1000000) return (v / 1000000).toFixed(1) + 'M';
            if (abs >= 1000) return (v / 1000).toFixed(1) + 'k';
            if (abs >= 100) return v.toFixed(0);
            if (abs >= 10) return v.toFixed(1);
            if (abs >= 1) return v.toFixed(2);
            return v.toPrecision(3);
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        // =================================================================
        // Connection & Stats
        // =================================================================

        function updateStats() {
            if (embedMode) return;  // No stats in embed mode

            const now = Date.now();
            if (now - lastRateUpdate >= 1000) {
                document.getElementById('msg-rate').textContent = msgsLastSec;
                msgsLastSec = 0;
                lastRateUpdate = now;
            }
            document.getElementById('total-msgs').textContent = msgCount.toLocaleString();

            const uptime = Math.floor((now - startTime) / 1000);
            document.getElementById('uptime').textContent =
                uptime < 60 ? uptime + 's' :
                uptime < 3600 ? Math.floor(uptime / 60) + 'm' :
                Math.floor(uptime / 3600) + 'h';

            requestAnimationFrame(updateStats);
        }
        if (!embedMode) {
            requestAnimationFrame(updateStats);
        }

        function connect() {
            const ws = new WebSocket(`ws://${location.host}/ws`);

            ws.onopen = () => {
                statusEl.className = 'connected';
                statusEl.textContent = 'Live';
            };

            ws.onclose = () => {
                statusEl.className = 'disconnected';
                statusEl.textContent = 'Reconnecting';
                setTimeout(connect, 2000);
            };

            ws.onerror = () => ws.close();

            ws.onmessage = (e) => {
                const data = JSON.parse(e.data);
                if (data.type === 'config') handleConfig(data);
                else if (data.type === 'history') handleHistory(data);
                else if (data.type === 'data') handleData(data);
            };
        }

        // Handle resize
        window.addEventListener('resize', () => {
            for (const w of Object.values(widgets)) {
                if (w.uplot) {
                    const container = w.element.querySelector('.chart-container');
                    w.uplot.setSize({
                        width: container.offsetWidth,
                        height: embedMode ? 200 : 120
                    });
                }
            }
        });

        connect();
    </script>
</body>
</html>
